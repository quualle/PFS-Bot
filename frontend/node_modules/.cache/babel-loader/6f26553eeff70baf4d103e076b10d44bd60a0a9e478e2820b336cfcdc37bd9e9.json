{"ast":null,"code":"var _jsxFileName = \"/Users/marcoheer/Desktop/privat/Programmierung/XORA/PFS-Bot/frontend/src/contexts/ChatContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useContext, useEffect } from 'react';\nimport axios from 'axios';\nimport { useAuth } from './AuthContext';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ChatContext = /*#__PURE__*/createContext({\n  messages: [],\n  isStreaming: false,\n  isLoading: false,\n  error: null,\n  sendMessage: async () => {},\n  clearMessages: async () => {},\n  provideMessageFeedback: async () => {},\n  notfallMode: false,\n  toggleNotfallMode: () => {}\n});\nexport const useChat = () => {\n  _s();\n  return useContext(ChatContext);\n};\n_s(useChat, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const ChatProvider = ({\n  children\n}) => {\n  _s2();\n  const [messages, setMessages] = useState([]);\n  const [isStreaming, setIsStreaming] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [notfallMode, setNotfallMode] = useState(false);\n  const {\n    user\n  } = useAuth();\n\n  // Load chat history when user is authenticated\n  useEffect(() => {\n    if (user) {\n      const loadChatHistory = async () => {\n        try {\n          setIsLoading(true);\n          const response = await axios.get('/api/chat/history');\n          if (response.data.history && Array.isArray(response.data.history)) {\n            const formattedMessages = response.data.history.map((msg, index) => ({\n              id: `history-${index}`,\n              role: msg.role || (msg.user ? 'user' : 'bot'),\n              content: msg.content || msg.user || msg.bot || '',\n              timestamp: new Date(msg.timestamp || Date.now()),\n              feedback: msg.feedback || null\n            }));\n            setMessages(formattedMessages);\n          }\n        } catch (error) {\n          console.error('Error loading chat history:', error);\n          setError('Failed to load chat history.');\n        } finally {\n          setIsLoading(false);\n        }\n      };\n      loadChatHistory();\n    }\n  }, [user]);\n\n  // Function to handle streaming responses from the API\n  const handleStreamedResponse = async (userMessage, controller) => {\n    const msgId = Date.now().toString();\n\n    // Add user message immediately\n    const userMsg = {\n      id: `user-${msgId}`,\n      role: 'user',\n      content: userMessage,\n      timestamp: new Date()\n    };\n\n    // Add a placeholder for the bot's message\n    const botMsg = {\n      id: `bot-${msgId}`,\n      role: 'bot',\n      content: '',\n      timestamp: new Date()\n    };\n    setMessages(prev => [...prev, userMsg, botMsg]);\n    try {\n      setIsStreaming(true);\n      const response = await fetch('/api/chat/message', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Requested-With': 'XMLHttpRequest',\n          'Accept': 'text/event-stream'\n        },\n        body: JSON.stringify({\n          message: userMessage,\n          notfallmodus: notfallMode ? '1' : '0',\n          stream: true\n        }),\n        signal: controller.signal\n      });\n      if (!response.ok || !response.body) {\n        throw new Error('Network response was not ok');\n      }\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n      let responseText = '';\n      while (true) {\n        const {\n          done,\n          value\n        } = await reader.read();\n        if (done) break;\n        const chunk = decoder.decode(value, {\n          stream: true\n        });\n\n        // Parse SSE events\n        const events = chunk.split('\\\\n\\\\n');\n        for (const event of events) {\n          if (event.startsWith('data:')) {\n            try {\n              const data = JSON.parse(event.substring(5).trim());\n              if (data.type === 'text' && data.content) {\n                responseText += data.content;\n                // Update bot message content as it streams in\n                setMessages(prev => prev.map(msg => msg.id === botMsg.id ? {\n                  ...msg,\n                  content: responseText\n                } : msg));\n              }\n            } catch (e) {\n              console.error('Error parsing SSE event:', e);\n            }\n          }\n        }\n      }\n\n      // Ensure complete message is set in state\n      setMessages(prev => prev.map(msg => msg.id === botMsg.id ? {\n        ...msg,\n        content: responseText\n      } : msg));\n    } catch (error) {\n      if (error.name !== 'AbortError') {\n        console.error('Error in streaming request:', error);\n        setError('Failed to get response from the bot. Please try again.');\n\n        // Show error message in the bot response\n        setMessages(prev => prev.map(msg => msg.id === botMsg.id ? {\n          ...msg,\n          content: 'Sorry, I encountered an error while processing your request. Please try again.'\n        } : msg));\n      }\n    } finally {\n      setIsStreaming(false);\n    }\n  };\n\n  // Function to send a message to the bot\n  const sendMessage = async content => {\n    if (!content.trim() || isStreaming) return;\n    setError(null);\n    const controller = new AbortController();\n    await handleStreamedResponse(content, controller);\n  };\n\n  // Function to clear all messages\n  const clearMessages = async () => {\n    try {\n      setIsLoading(true);\n      await axios.post('/api/chat/clear');\n      setMessages([]);\n    } catch (error) {\n      console.error('Error clearing messages:', error);\n      setError('Failed to clear messages. Please try again.');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Function to provide feedback on a message\n  const provideMessageFeedback = async (messageId, feedbackType, comment) => {\n    try {\n      await axios.post('/api/feedback', {\n        message_id: messageId,\n        feedback_type: feedbackType,\n        comment: comment || ''\n      });\n\n      // Update message with feedback in state\n      setMessages(prev => prev.map(msg => msg.id === messageId ? {\n        ...msg,\n        feedback: feedbackType\n      } : msg));\n    } catch (error) {\n      console.error('Error sending feedback:', error);\n      setError('Failed to send feedback. Please try again.');\n    }\n  };\n\n  // Function to toggle notfall mode\n  const toggleNotfallMode = () => {\n    setNotfallMode(prev => !prev);\n  };\n  return /*#__PURE__*/_jsxDEV(ChatContext.Provider, {\n    value: {\n      messages,\n      isStreaming,\n      isLoading,\n      error,\n      sendMessage,\n      clearMessages,\n      provideMessageFeedback,\n      notfallMode,\n      toggleNotfallMode\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 236,\n    columnNumber: 5\n  }, this);\n};\n_s2(ChatProvider, \"jO16wKPHwSdqKyE/59WA52Y5sS0=\", false, function () {\n  return [useAuth];\n});\n_c = ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useEffect","axios","useAuth","jsxDEV","_jsxDEV","ChatContext","messages","isStreaming","isLoading","error","sendMessage","clearMessages","provideMessageFeedback","notfallMode","toggleNotfallMode","useChat","_s","ChatProvider","children","_s2","setMessages","setIsStreaming","setIsLoading","setError","setNotfallMode","user","loadChatHistory","response","get","data","history","Array","isArray","formattedMessages","map","msg","index","id","role","content","bot","timestamp","Date","now","feedback","console","handleStreamedResponse","userMessage","controller","msgId","toString","userMsg","botMsg","prev","fetch","method","headers","body","JSON","stringify","message","notfallmodus","stream","signal","ok","Error","reader","getReader","decoder","TextDecoder","responseText","done","value","read","chunk","decode","events","split","event","startsWith","parse","substring","trim","type","e","name","AbortController","post","messageId","feedbackType","comment","message_id","feedback_type","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/marcoheer/Desktop/privat/Programmierung/XORA/PFS-Bot/frontend/src/contexts/ChatContext.tsx"],"sourcesContent":["import React, { createContext, useState, useContext, useEffect } from 'react';\nimport axios from 'axios';\nimport { useAuth } from './AuthContext';\n\nexport interface Message {\n  id: string;\n  role: 'user' | 'bot';\n  content: string;\n  timestamp: Date;\n  feedback?: 'positive' | 'negative' | null;\n}\n\ninterface ChatContextType {\n  messages: Message[];\n  isStreaming: boolean;\n  isLoading: boolean;\n  error: string | null;\n  sendMessage: (content: string) => Promise<void>;\n  clearMessages: () => Promise<void>;\n  provideMessageFeedback: (messageId: string, feedbackType: 'positive' | 'negative', comment?: string) => Promise<void>;\n  notfallMode: boolean;\n  toggleNotfallMode: () => void;\n}\n\nconst ChatContext = createContext<ChatContextType>({\n  messages: [],\n  isStreaming: false,\n  isLoading: false,\n  error: null,\n  sendMessage: async () => {},\n  clearMessages: async () => {},\n  provideMessageFeedback: async () => {},\n  notfallMode: false,\n  toggleNotfallMode: () => {},\n});\n\nexport const useChat = () => useContext(ChatContext);\n\nexport const ChatProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [isStreaming, setIsStreaming] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [notfallMode, setNotfallMode] = useState(false);\n  const { user } = useAuth();\n\n  // Load chat history when user is authenticated\n  useEffect(() => {\n    if (user) {\n      const loadChatHistory = async () => {\n        try {\n          setIsLoading(true);\n          const response = await axios.get('/api/chat/history');\n          \n          if (response.data.history && Array.isArray(response.data.history)) {\n            const formattedMessages = response.data.history.map((msg: any, index: number) => ({\n              id: `history-${index}`,\n              role: msg.role || (msg.user ? 'user' : 'bot'),\n              content: msg.content || msg.user || msg.bot || '',\n              timestamp: new Date(msg.timestamp || Date.now()),\n              feedback: msg.feedback || null,\n            }));\n            \n            setMessages(formattedMessages);\n          }\n        } catch (error) {\n          console.error('Error loading chat history:', error);\n          setError('Failed to load chat history.');\n        } finally {\n          setIsLoading(false);\n        }\n      };\n\n      loadChatHistory();\n    }\n  }, [user]);\n\n  // Function to handle streaming responses from the API\n  const handleStreamedResponse = async (userMessage: string, controller: AbortController) => {\n    const msgId = Date.now().toString();\n    \n    // Add user message immediately\n    const userMsg: Message = {\n      id: `user-${msgId}`,\n      role: 'user',\n      content: userMessage,\n      timestamp: new Date(),\n    };\n    \n    // Add a placeholder for the bot's message\n    const botMsg: Message = {\n      id: `bot-${msgId}`,\n      role: 'bot',\n      content: '',\n      timestamp: new Date(),\n    };\n    \n    setMessages(prev => [...prev, userMsg, botMsg]);\n    \n    try {\n      setIsStreaming(true);\n      const response = await fetch('/api/chat/message', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Requested-With': 'XMLHttpRequest',\n          'Accept': 'text/event-stream',\n        },\n        body: JSON.stringify({\n          message: userMessage,\n          notfallmodus: notfallMode ? '1' : '0',\n          stream: true,\n        }),\n        signal: controller.signal,\n      });\n      \n      if (!response.ok || !response.body) {\n        throw new Error('Network response was not ok');\n      }\n      \n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n      let responseText = '';\n      \n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        \n        const chunk = decoder.decode(value, { stream: true });\n        \n        // Parse SSE events\n        const events = chunk.split('\\\\n\\\\n');\n        for (const event of events) {\n          if (event.startsWith('data:')) {\n            try {\n              const data = JSON.parse(event.substring(5).trim());\n              if (data.type === 'text' && data.content) {\n                responseText += data.content;\n                // Update bot message content as it streams in\n                setMessages(prev => \n                  prev.map(msg => \n                    msg.id === botMsg.id \n                      ? { ...msg, content: responseText } \n                      : msg\n                  )\n                );\n              }\n            } catch (e) {\n              console.error('Error parsing SSE event:', e);\n            }\n          }\n        }\n      }\n      \n      // Ensure complete message is set in state\n      setMessages(prev => \n        prev.map(msg => \n          msg.id === botMsg.id \n            ? { ...msg, content: responseText } \n            : msg\n        )\n      );\n      \n    } catch (error) {\n      if ((error as Error).name !== 'AbortError') {\n        console.error('Error in streaming request:', error);\n        setError('Failed to get response from the bot. Please try again.');\n        \n        // Show error message in the bot response\n        setMessages(prev => \n          prev.map(msg => \n            msg.id === botMsg.id \n              ? { ...msg, content: 'Sorry, I encountered an error while processing your request. Please try again.' } \n              : msg\n          )\n        );\n      }\n    } finally {\n      setIsStreaming(false);\n    }\n  };\n\n  // Function to send a message to the bot\n  const sendMessage = async (content: string) => {\n    if (!content.trim() || isStreaming) return;\n    \n    setError(null);\n    const controller = new AbortController();\n    \n    await handleStreamedResponse(content, controller);\n  };\n\n  // Function to clear all messages\n  const clearMessages = async () => {\n    try {\n      setIsLoading(true);\n      await axios.post('/api/chat/clear');\n      setMessages([]);\n    } catch (error) {\n      console.error('Error clearing messages:', error);\n      setError('Failed to clear messages. Please try again.');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Function to provide feedback on a message\n  const provideMessageFeedback = async (messageId: string, feedbackType: 'positive' | 'negative', comment?: string) => {\n    try {\n      await axios.post('/api/feedback', {\n        message_id: messageId,\n        feedback_type: feedbackType,\n        comment: comment || '',\n      });\n      \n      // Update message with feedback in state\n      setMessages(prev => \n        prev.map(msg => \n          msg.id === messageId \n            ? { ...msg, feedback: feedbackType } \n            : msg\n        )\n      );\n    } catch (error) {\n      console.error('Error sending feedback:', error);\n      setError('Failed to send feedback. Please try again.');\n    }\n  };\n\n  // Function to toggle notfall mode\n  const toggleNotfallMode = () => {\n    setNotfallMode(prev => !prev);\n  };\n\n  return (\n    <ChatContext.Provider\n      value={{\n        messages,\n        isStreaming,\n        isLoading,\n        error,\n        sendMessage,\n        clearMessages,\n        provideMessageFeedback,\n        notfallMode,\n        toggleNotfallMode,\n      }}\n    >\n      {children}\n    </ChatContext.Provider>\n  );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}